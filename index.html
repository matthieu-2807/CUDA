<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Cuda : Fichiers sources pour le cours de CUDA" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Cuda</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/matthieu-2807/CUDA">View on GitHub</a>

          <h1 id="project_title">Cuda</h1>
          <h2 id="project_tagline">Fichiers sources pour le cours de CUDA</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/matthieu-2807/CUDA/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/matthieu-2807/CUDA/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h3>
<a name="bienvenue" class="anchor" href="#bienvenue"><span class="octicon octicon-link"></span></a>Bienvenue</h3>

<p><strong>Le rapport et les fichiers sources utilisés lors du cours de CUDA avec M.GABER sont disponibles en téléchargement dans les fichiers .ZIP et TAR.GZ ci-dessus.</strong></p>

<h3>
<a name="lab-0---cuda-hello-world-" class="anchor" href="#lab-0---cuda-hello-world-"><span class="octicon octicon-link"></span></a>Lab 0 - CUDA Hello World !</h3>

<p>Le Lab 0 est la découverte de CUDA, nous commençons donc avec le fameux Hello World.</p>

<div class="highlight highlight-c"><pre><span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="n">__global__</span> <span class="kt">void</span> <span class="nf">kernel</span><span class="p">(</span><span class="kt">void</span><span class="p">){}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">kernel</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;&gt;&gt;</span><span class="p">();</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Hello World !</span><span class="se">\n</span><span class="s">);</span>
    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<h3>
<a name="lab-1" class="anchor" href="#lab-1"><span class="octicon octicon-link"></span></a>Lab 1</h3>

<p>L'étape suivante est l'allocation de mémoire dans le GPU, l'échange de données entre le CPU et le GPU et l'exécution du code dans le GPU. Nous ajoutons à cela un timer et une gestion des erreurs lors des allocations de mémoire.</p>

<div class="highlight highlight-c"><pre><span class="n">__global__</span>  <span class="kt">void</span> <span class="nf">vecAdd</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span> <span class="n">A</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">B</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">C</span><span class="p">)</span> 
<span class="p">{</span>  
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> 
    <span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> 
<span class="p">}</span>

<span class="cp">#define cudaSafeCall(err) __cudaSafeCall(err, __FILE__, __LINE__)</span>
<span class="kt">void</span> <span class="nf">__cudaSafeCall</span><span class="p">(</span><span class="n">cudaError_t</span> <span class="n">err</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">line</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">err</span><span class="p">)</span> <span class="o">!=</span> <span class="n">cudaSuccess</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"CUDA error in file %s at line %i: %s.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">cudaGetErrorString</span><span class="p">(</span><span class="n">err</span><span class="p">));</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

</pre></div>

<h3>
<a name="lab-2--device-management-api" class="anchor" href="#lab-2--device-management-api"><span class="octicon octicon-link"></span></a>Lab 2 : Device Management API</h3>

<p>Cette partie consiste à s'assurer que le GPU est compatible avec le code que nous souhaitons exécuter. Ici nous utilisons un GPU qui a la version 2.1, mais notre code vérifie que le GPU soit équipé d'une version 1.3 ou plus.
De plus, nous séparons les codes C et CUDA dans des fichiers différents et réalisons un makefile permettant de compiler plusieurs fichier (.c et .cu) en une commande.</p>

<div class="highlight highlight-c"><pre><span class="kt">void</span> <span class="nf">cudaDeviceInit</span><span class="p">(</span><span class="kt">int</span> <span class="n">major</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minor</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">devCount</span><span class="p">,</span> <span class="n">device</span><span class="p">;</span>
    <span class="n">cudaGetDeviceCount</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devCount</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">devCount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"No CUDA capable devices detected. </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">device</span> <span class="o">&lt;</span> <span class="n">devCount</span><span class="p">;</span> <span class="n">device</span><span class="o">++</span><span class="p">){</span>
        <span class="n">cudaDeviceProp</span> <span class="n">props</span><span class="p">;</span>
        <span class="n">cudaGetDeviceProperties</span><span class="p">(</span><span class="o">&amp;</span><span class="n">props</span><span class="p">,</span> <span class="n">device</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">props</span><span class="p">.</span><span class="n">major</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="p">(</span><span class="n">props</span><span class="p">.</span><span class="n">major</span> <span class="o">==</span> <span class="n">major</span> <span class="o">&amp;&amp;</span> <span class="n">props</span><span class="p">.</span><span class="n">minor</span> <span class="o">&gt;=</span> <span class="n">minor</span><span class="p">))</span> <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">device</span> <span class="o">==</span> <span class="n">devCount</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"No device above 1.2 compute capability detected. </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="n">cudaSetDevice</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<h3>
<a name="lab-3--sum--dot-product" class="anchor" href="#lab-3--sum--dot-product"><span class="octicon octicon-link"></span></a>Lab 3 : Sum / Dot product</h3>

<p>Il s'agit ici de faire un produit scalaire en partant du code s'exécutant sur le CPU et en le rendant exécutable sur le GPU. Le produit scalaire (dot product) consiste à prendre des groupes de 2 nombres (entiers, décimaux, …) et de faire la somme des produits de ces 2 nombres.</p>

<p>Voici le code utilisé par le GPU pour le produit scalaire :</p>

<div class="highlight highlight-c"><pre><span class="n">__global__</span> <span class="kt">void</span> <span class="nf">dot</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">A</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">B</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">S</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">__shared__</span> <span class="kt">float</span> <span class="n">temp</span><span class="p">[</span><span class="n">THREADS_PER_BLOCK</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
    <span class="n">temp</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>

    <span class="n">__syncthreads</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">THREADS_PER_BLOCK</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

        <span class="n">atomicAdd</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<h3>
<a name="lab-4--matrix-matrix-multiplication" class="anchor" href="#lab-4--matrix-matrix-multiplication"><span class="octicon octicon-link"></span></a>Lab 4 : Matrix-Matrix multiplication</h3>

<p>Les jeux vidéos utilisent en permanence des matrices afin de mettre à jour les données à afficher sur votre écran. Cela peut être l'affichage d'un personnage ou le déplacement de la caméra. Nous allons voir ici un petit exemple d'utilisation de CUDA pour exécuter des traitements parallèles sur de très grandes matrices.</p>

<p>Dans l'exemple présenté, nous utilisons CUDA pour récupérer le résultat d'une multiplication entre 2 matrices. Par défaut, nous aurions tendance à boucler sur les différents éléments des 2 matrices pour effectuer nos calculs. Grâce au traitement, nous pouvons réduire ces boucles (3) à une seule boucle qui parcourt chaque élement de la matrice finale.</p>

<h3>
<a name="auteurs" class="anchor" href="#auteurs"><span class="octicon octicon-link"></span></a>Auteurs</h3>

<p>Les étudiants ayant participés à ce projet sont M. David BOTTIAU et M. Matthieu LEFEVRE, étudiants en 4ème année à l'EPSI d'Arras.</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Cuda maintained by <a href="https://github.com/matthieu-2807">matthieu-2807</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
